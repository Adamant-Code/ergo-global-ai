stages: [build, deploy]

default:
  image: docker:24.0.9
  before_script:
    # Safer shell defaults and basic tooling
    - set -euo pipefail
    # Install AWS CLI and jq from Alpine repositories
    - apk add --no-cache aws-cli jq
    - aws --version
    # Request a GitLab OIDC ID token and assume the AWS role
    # Ensure CI/CD variable AWS_ROLE_ARN is set to your IAM role ARN
    - echo "Assuming AWS role via OIDCâ€¦"
    - |
      if [ -z "${AWS_ROLE_ARN:-}" ]; then
        echo "ERROR: AWS_ROLE_ARN is not set" >&2
        exit 1
      fi
    - printf "%s" "${GITLAB_OIDC_TOKEN}" > /tmp/gitlab-oidc-token
    - export AWS_ROLE_ARN="${AWS_ROLE_ARN}"
    - export AWS_WEB_IDENTITY_TOKEN_FILE=/tmp/gitlab-oidc-token
    - export AWS_DEFAULT_REGION="${AWS_REGION}"
    - aws sts get-caller-identity
  id_tokens:
    GITLAB_OIDC_TOKEN:
      aud: https://gitlab.com

variables:
  AWS_REGION: "eu-west-1" # override in GitLab CI/CD variables
  ECR_REPO: "ergoglobal-ai" # ECR repo
  CLUSTER: "ergoglobal-ai"
  SERVICE: "ergoglobal-ai"
  DOCKER_HOST: tcp://docker:2375
  DOCKER_DRIVER: overlay2
  DOCKER_TLS_CERTDIR: ""
  DOCKER_BUILDKIT: "1"
  GIT_DEPTH: "1" # shallow clone for speed

services:
  - docker:dind

build:
  stage: build
  script:
    - ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
    - REGISTRY="$ACCOUNT_ID.dkr.ecr.$AWS_REGION.amazonaws.com"
    # Login to ECR (recommended flow)
    - aws ecr get-login-password --region $AWS_REGION | docker login --username AWS --password-stdin "$REGISTRY"
    # Ensure repository exists
    - aws ecr describe-repositories --repository-names "$ECR_REPO" >/dev/null 2>&1 || aws ecr create-repository --repository-name "$ECR_REPO"
    # Use buildx and embed inline cache in the pushed images (reliable on ECR)
    - IMAGE_SHA="$REGISTRY/$ECR_REPO:$CI_COMMIT_SHA"
    - IMAGE_BRANCH="$REGISTRY/$ECR_REPO:$CI_COMMIT_REF_SLUG"
    - docker buildx create --use --name builder-$CI_PIPELINE_ID
    - docker buildx inspect --bootstrap
    - docker buildx build --file apps/ai-service/Dockerfile --build-arg GIT_COMMIT_SHA=$CI_COMMIT_SHA --tag "$IMAGE_SHA" --tag "$IMAGE_BRANCH" --cache-from type=registry,ref=$IMAGE_BRANCH --cache-from type=registry,ref=$REGISTRY/$ECR_REPO:main --cache-to type=inline --provenance=false --progress=plain --push .

deploy:
  stage: deploy
  needs: ["build"]
  services: []
  script:
    - ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)
    - REGISTRY="$ACCOUNT_ID.dkr.ecr.$AWS_REGION.amazonaws.com"
    - IMAGE="$REGISTRY/$ECR_REPO:$CI_COMMIT_SHA"
    # Inject image and ensure logs region matches AWS_REGION
    - jq --arg img "$IMAGE" --arg region "$AWS_REGION" '.containerDefinitions[].image=$img | .containerDefinitions[].logConfiguration.options["awslogs-region"]=$region' deploy/ecs/taskdef.template.json > taskdef.out.json
    # Register new task-def revision
    - TASK_DEF_ARN=$(aws ecs register-task-definition --cli-input-json file://taskdef.out.json --query taskDefinition.taskDefinitionArn --output text)
    # Roll service to new revision
    - aws ecs update-service --cluster "$CLUSTER" --service "$SERVICE" --task-definition "$TASK_DEF_ARN" --force-new-deployment
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'
